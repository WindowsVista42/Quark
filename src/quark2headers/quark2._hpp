#pragma once
#ifndef QUARK_HPP
#define QUARK_HPP

#include <cstdint>
#include <cstdio>
#include <iostream>
#include <vector>

#define _USE_MATH_DEFINES
#include <math.h>

#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>
#include <VkBootstrap.h>

#ifndef QUARK_INTERNALS // Sean: this macro is needded because vma is really fucky
#define VMA_IMPLEMENTATION
#endif

#include <tiny_obj_loader.h>
#include <vk_mem_alloc.h>

#include <entt/entity/entity.hpp>
#include <entt/entity/registry.hpp>

#include <btBulletDynamicsCommon.h>
#include <BulletCollision/CollisionDispatch/btGhostObject.h>

//#include "quark.hpp"
#include "quark2_types.hpp"
#include "quark2_math.hpp"
#include "quark2_physics.hpp"
#include "quark2_assets.hpp"
#include "quark2_renderer.hpp"
#include "quark2_platform.hpp"
#include "quark2_alloc.hpp"
#include "quark2_scenes.hpp"

namespace quark {

inline bool enable_performance_statistics = false; // Print performance numbers
inline f32 dt = 1.0f / 60.0f; // Frame delta time
inline f32 tt = 0.0f;         // Total elapsed time

inline LinearAllocator scratch_alloc;

void run();

namespace internal {

void init();
void deinit();

};

};

using namespace quark;                  // quark.hpp
using namespace quark::types;           // quark_types.hpp
using namespace quark::math::types;     // quark_math.hpp
using namespace quark::physics::types;  // quark_physics.hpp
using namespace quark::alloc::types;    // quark_alloc.hpp
using namespace quark::platform::types; // quark_platform.hpp
using namespace quark::renderer::types; // quark_render.hpp
using namespace quark::assets::types;   // quark_assets.hpp
using namespace quark::ecs::types;      // quark_ecs.hpp

namespace quark {

namespace types {


struct AllocatedBuffer { VmaAllocation alloc; VkBuffer buffer; };
struct AllocatedImage  { VmaAllocation alloc; VkImage image; VkImageView view; VkFormat format; };
};

};

namespace quark {

namespace ecs {

namespace types {

struct Entity : entt::entity {};

};

inline entt::basic_registry<entt::entity> registry;

entt::entity static new() { return registry.create(); };
};

};

namespace quark {

namespace physics {

namespace types {};

inline btDefaultCollisionConfiguration* config;
inline btCollisionDispatcher* dispatcher;
inline btBroadphaseInterface* overlapping_pair_cache;
inline btSequentialImpulseConstraintSolver* solver;
inline btDiscreteDynamicsWorld* world;

add_rigid_body(RigidBody* rb);

namespace internal {};
};

};

physics::add_rigid_body();

namespace quark {

namespace assets {

inline AssetManager assets;

namespace internal {};
};

};

namespace quark {

namespace renderer {

inline mat4 projection_matrix;
inline mat4 view_matrix;
inline mat4 view_projection_matrix;

inline vec2 mouse_pos;
inline vec2 view_spherical_dir = {0.0f, M_PI_2};
inline f32 mouse_sensitivity = 2.0f; // TODO: load from file

// CAMERA STUFF THAT YOU CAN CHANGE

inline vec3 camera_position = {0.0f, 0.0f, 0.0f};
inline vec3 camera_direction = {1.0f, 0.0f, 0.0f};
inline f32 camera_znear = 0.01f;
inline f32 camera_zfar = 10000.0f;
inline f32 camera_fov = 90.0f;

inline CullData cull_data;
inline vec4 planes[6];

inline LinearAllocator render_alloc;
inline VmaAllocator gpu_alloc;

void update_camera();

void begin_frame();
void end_frame();

void begin_lit_pass();
void draw_lit(Pos pos, Rot rot, Scl scl, Mesh mesh, usize index);
void end_lit_pass();

void add_to_render_batch(Pos pos, Rot rot, Scl scl, Mesh mesh);

template <typename F> void flush_render_batch(F f);

void begin_solid_pass();
void end_solid_pass();

void begin_wireframe_pass();
void end_wireframe_pass();

void draw_color(Pos pos, Rot rot, Scl scl, Col col, Mesh mesh);

void begin_forward_rendering();
void end_forward_rendering();

void begin_depth_prepass_rendering();
void draw_depth(Pos pos, Rot rot, Scl scl, Mesh mesh);
void end_depth_prepass_rendering();

void begin_shadow_rendering();
void draw_shadow(Pos pos, Rot rot, Scl scl, Mesh mesh);
void end_shadow_rendering();

void render_frame(bool end_forward);

namespace internal {};
};

};

namespace quark {

namespace platform {

inline const char* window_name = "Quark Game Engine";
inline GLFWwindow* window_ptr; // GLFW window pointer

namespace internal {};
};

};

namespace quark {

namespace math {

namespace internal {};
};

};

namespace quark {

namespace alloc {

namespace internal {};
};

};

namespace quark {

namespace scenes {

inline void (*init_func)();
inline void (*update_func)();
inline void (*deinit_func)();

void next_scene(void (*init), void (*update), void (*) deinit);

namespace internal {};
};

};

#include "thing.hpp"

#endif//QUARK_ECS_HPP
